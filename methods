#include <iostream>
#include <cmath>
#include <iomanip>
using namespace std;

// ЛАБОРАТНОРАЯ РАБОТА 1
// ЗАДАНИЕ 1
// Функция для вычисления erf через ряд Тейлора
//double func(double x) {
//    const double PI = acos(-1.0);
//    const double first_part = 2.0 / sqrt(PI);
//
//    double full_sum = 0.0; // сумма всех членов ряда
//    double term = x;       // текущий член ряда
//    int n = 0;             // итерация в ряде
//
//    do {
//        full_sum += term; // добавляем текущий член к общей сумме
//        n++;
//        term *= -x * x * (2 * n - 1) / (n * (2 * n + 1)); // обновляем текущий член ряда
//    } while (fabs(term) > 1e-10); // будет выполняться, пока текущий член ряда больше эпсилон
//
//    return first_part * full_sum; // итоговая сумма ряда
//}
//
//int main() {
//    double xs[4] = { 0.5, 1.0, 5.0, 10.0 }; // массив иксов
//
//    // красивый вывод
//    cout << fixed << setprecision(10); // 10 знаков после запятой
//
//
//    cout << setw(8) << "x" << " | "
//        << setw(16) << "(func)" << " | "
//        << setw(16) << "(std::erf)" << " | "
//        << setw(16) << "Difference" << endl;
//
//    cout << string(60, '-') << endl;
//
//
//    for (int i = 0; i < 4; ++i) {
//        double result_func = func(xs[i]);       // результат func 
//        double result_erf = erf(xs[i]);         // Результат erf из стандартной библиотеки
//        double difference = fabs(result_func - result_erf); // Разница между func и erf
//
//        cout << setw(8) << xs[i] << " | "
//            << setw(16) << result_func << " | "
//            << setw(16) << result_erf << " | "
//            << setw(16) << difference << endl;
//    }
//
//    return 0;
//}


// ЗАДАНИЕ 2
// Функция для вычисления суммы ряда phi(x) с заданной точностью - epsilon
//double phi(double x, double epsilon) {
//    double sum = 0.0;  // инициализация суммы ряда
//    double term;       // переменная для хранения текущего члена ряда
//    int k = 1;         // начальное значение индекса k
//
//    // цикл для вычисления суммы ряда до тех пор, пока модуль текущего члена больше epsilon
//    do {
//        term = 1.0 / (k * (k + x));  // вычисление текущего члена ряда
//        sum += term;                 // добавление текущего члена к сумме
//        k++;                         
//    } while (fabs(term) > epsilon);  // проверка условия завершения цикла
//
//    return sum;  
//}
//
//// с использованием соотношения 1/(k*(k+1)) = 1/k - 1/(k+1)
//double phi_1(double epsilon) {
//    double sum = 0.0;  
//    double term;       
//    int k = 1;        
//
//
//    do {
//        term = 1.0 / k - 1.0 / (k + 1);  
//        sum += term;                     
//        k++;                            
//    } while (fabs(term) > epsilon);      
//
//    return sum;  
//}
//
//// для вычисления разности phi(x) - phi(1) с использованием более быстро сходящегося ряда
//double phi_diff(double x, double epsilon) {
//    double sum = 0.0;  
//    double term;       
//    int k = 1;         
//
//    do {
//        term = (1.0 - x) / (k * (k + x) * (k + 1));  //упростили выражение phi(x) - phi(1) 
//        sum += term;                                 
//        k++;                                         
//    } while (fabs(term) > epsilon);                  
//
//    return sum;  
//}
//
//int main() {
//    double epsilon = 0.5e-8;  // допустимая ошибка
//
//    cout << "x from 0.1 to 1" << endl;
//    for (double x = 0.0; x <= 1.0; x += 0.1) {
//        double result = phi(x, epsilon);  
//        cout << "phi(" << x << ") = " << result << endl;  
//    }
//
//    cout << endl << "proof using the ratio:" << endl;
//    double phi_1_result = phi_1(epsilon);
//    cout << "phi(1) = " << phi_1_result << endl << endl;
//
//    cout << "phi(x) - phi(1):" << endl;
//    for (double x = 0.0; x <= 1.0; x += 0.1) {
//        double diff = phi_diff(x, epsilon);
//        cout << "phi(" << x << ") - phi(1) = " << diff << endl;
//    }
//
//    //отклонения связаны с численными погрешностями из-за конечного числа итераций
//}

//ЗАДАНИЕ 3
//сделал

//ЗАДАНИЕ 4
//сделал

//ЛАБОРАТОРНАЯ 2
// Функция для решения квадратного уравнения
void solveQuadratic(long double a, long double b, long double c) {
    // проверка на случай, когда все коэффициенты равны нулю
    if (a == 0 && b == 0 && c == 0) {
        cout << "Все комплексные числа удовлетворяют уравнению." << endl;
        return;
    }

    // Проверка на случай, когда a = 0, b = 0, но c != 0
    if (a == 0 && b == 0 && c != 0) {
        cout << "Ни одно комплексное число не удовлетворяет уравнению." << endl;
        return;
    }

    // обработка переполнения и машинных нулей: если коэффициенты слишком большие или маленькие, нормализуем их
    long double scale = max(abs(a), max(abs(b), abs(c)));
    if (scale > numeric_limits<long double>::max() / 10 || scale < numeric_limits<long double>::min() * 10) {
        a /= scale;
        b /= scale;
        c /= scale;
    }

    // если a == 0, уравнение становится линейным
    if (a == 0) {
        if (b != 0) {
            cout << fixed << setprecision(11); // точность до 11 знаков
            cout << "Уравнение линейное. Корень: x = " << -c / b << endl;
        }
        else {
            cout << "Некорректное уравнение." << endl;
        }
        return;
    }

    // вычисление дискриминанта
    long double discriminant = b * b - 4 * a * c;

    // Если чувствительное уравнение
    // Если дискриминант отрицательный, корни комплексные
    if (discriminant < 0) {
        long double realPart = -b / (2 * a);
        long double imaginaryPart = sqrt(-discriminant) / (2 * a);
        cout << fixed << setprecision(11); // Устанавливаем точность до 11 знаков
        cout << "Корни комплексные: " << endl;
        cout << "x1 = " << realPart << " + " << imaginaryPart << "i" << endl;
        cout << "x2 = " << realPart << " - " << imaginaryPart << "i" << endl;
        return;
    }

    // численно устойчивый способ вычисления корней
    // использование знака b для минимизации потери точности
    long double sqrtDiscriminant = sqrt(discriminant);
    long double x1, x2;

    if (b >= 0) {
        x1 = (-b - sqrtDiscriminant) / (2 * a); // минимизация ошибок округления
        x2 = c / (a * x1); // второй корень через соотношение
    }
    else {
        x1 = (-b + sqrtDiscriminant) / (2 * a); // минимизация ошибок округления
        x2 = c / (a * x1); // второй корень через соотношение
    }

    // находятся ли корни в допустимых пределах
    // определение границ для чисел с плавающей точкой
    long double lowerBound = numeric_limits<long double>::min();
    long double upperBound = numeric_limits<long double>::max();

    cout << fixed << setprecision(11); // устанавливаем точность до 11 знаков
    if (abs(x1) < lowerBound || abs(x1) > upperBound) {
        cout << "Корень x1 выходит за пределы допустимого диапазона." << endl;
    }
    else {
        cout << "Корень x1 = " << x1 << endl;
    }

    if (abs(x2) < lowerBound || abs(x2) > upperBound) {
        cout << "Корень x2 выходит за пределы допустимого диапазона." << endl;
    }
    else {
        cout << "Корень x2 = " << x2 << endl;
    }
}

int main() {
    setlocale(LC_ALL, "Russian");
    cout << "Введите коэффициенты a, b, c для уравнения ax^2 + bx + c = 0:" << endl;
    long double a, b, c;
    cin >> a >> b >> c;

    solveQuadratic(a, b, c);

    return 0;
}
